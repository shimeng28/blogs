---
title: ES6-变量的解构赋值
date: 2018-11-04 13:32:58
tags:
---
一、 变量的解构赋值

变量的解构赋值就是通过模式的匹配，提取相应的字段值（解构），并对变量赋值（赋值)。如
```
  let { test } = { test: 1};
```

1. 数组的解构赋值
  
```js   
    let [a1] = [1, 2, 3];
    console.log(a1);
```
  以上a的值为1，这是因为左边为一个数组，其内的为变量声明，声明了一个a变量，通过相对位置，索引到右侧数组中相同索引的值，并将右边的值赋值给a。但是如果右边不是一个数组，那么便会报TypeError错误。因为只有等号左右两边的模式匹配，左边的变量才能匹配到右边的值。
  
2. 对象的解构赋值

数组是通过相对位置，索引到相应的值，在对象中属性是无序的，这个时候就必须通过相同属性才能解构。

```js
  let { a2 } = { a2: 1};
  let { a3: a4 } = { a3: 1 };
  console.log(a2);
  console.log(a4);
  console.log(a3);
```
在这里，a2, a4的值为1，a3提示ReferenceError。这是因为a3作为模式，a4为变量声明。在这之后，a3并未被声明赋值，我们只是通过a3找到了等号右边a3属性的值，并声明a4, 把等号右边a3的值赋值给a4。那么为什么a2没有问题呢？因为

```js
let { a2 } = { a2: 1} 
```
也是

```js
let { a2: a2 } = { a2: 1}
```
但是需要注意的是，如果大括号在行首的话，会报错。

3. 字符串的解构赋值

字符串会被转化为类似于数组的对象。

```
  let [ a5, a6, a7 ] = 'abcde';
  console.log(a5);
  console.log(a6);
  console.log(a7);  
```
这个a5， a6, a7分别为 'a', 'b', 'c', 通过将'abcde'装换为

```
{0: a, 1: b, 2: c, 3: d, 4: e}
```

4. 数值和布尔值的解构赋值

解构赋值时，如果等号右边不是对象，则会转回为对象，所以，数值和布尔值会分别转换为 Number对象和 Boolean对象。
  
  ```
    let { toString: a8 } = 123;
    console.log(a8);
    console.log(Number.prototype.toString === a8);
  ```

5. undefined 和 null的解构赋值
  
如果等号右边为undefined和null的时候，我们会得到一个什么样的结果呢？
  
  ```
    let { a9 } = undefined;
    let { a10 } = null;
  ```
报错

```
Uncaught TypeError: Cannot destructure property a9 of undefined or null.
```
  
结果显而易见，解构赋值的等号右边不支持undefined和null。并且如果匹配到的值，完全相等于undefined的时候，我们还可以设置默认值。即：

```
let { a11 = 1 } = { }; // 这个里面a11 值为1
```
   
```
let { a12 = 1 } = { a12: null }; // 这个里面a12 值为null.
```
   
因此只有完全相等于undefined的时候，我们的默认值才会生效

6. 圆括号问题

对于编译器来说，不能存在二义性，因此当我们将大括号放到解构赋值的行首的时候，JavaScript引擎就无法得知当前是代码块，还是解构赋值，因此便会报错。同样对于圆括号也是同样的道理，对于包含圆括号的解构赋值，编译的时候，当前是模式还是一个表达式，只有解析到等号才能知道。

因此在解构赋值中变量声明和赋值语句的模式部分不能有圆括号，但是在赋值语句的非模式部分可以有圆括号。

```
  let { (a13) } = { a13: 1};  // 变量声明部分  报错
  let { (a14) : a15 } = { a14: 1};  // 赋值语句的模式部分 报错
  ({ a16 : (a17) } = { });  // 赋值语句的非模式部分 正确
```













