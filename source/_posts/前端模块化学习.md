---
title: 前端模块化学习(一)
date: 2017-12-24 21:11:35
tags: 前端工程化
---
前端模块化不是上来就有的，它也是随着前端业务的发展，逐渐完善，形成了今天复杂而又难用的配置。由于JavaScript刚出现时只是为了完成表单的提交，并没有特别复杂的业务。因此在JS中是没有模块化的概念的。随着时代的发展，对前端的要求越来越复杂。需要复用的代码越来越多，全局变量使代码越来越难以维护。

于是前端出现了IIFE模式，来模块化代码

	(function(){
		// write code here  
	})()
	
我们将代码也在函数体内，利用闭包的特性，防止了全局变量的污染，同时当我们想要复用代码时，便可以通过`<script>`标签引用通用代码。当我们想要使用全局变量的时候可以向函数中传入window对象。代码如下：

	（function(global) {
		// write code here
	 })(window);
	 
现在随着JS的发展，ES6中增加了`import`和`export`实现模块化。如果这样就万事大吉，那么世界也就太美好了。可惜，我们的这种JS文件的引用只能是顺序的，而现实业务代码中往往是树状的，简单的顺序依赖是没有办法满足JSer的要求的; 并且还有一个问题是，我们将通用代码拿出来，如果考虑极端一点，我们就会有非常多的文件，而每一个文件都会需要HTTP请求，那就会因为请求过多，用户体验极差。

这个时候前端大佬们开始拯救世界了。因为一个良好的系统必然是需要模块化的，我们需要将HTML，CSS，JS统统模块化，CSS虽然有import语法，但是因为页面其不能并行下载，所以是不建议使用。而JavaScript诞生的时候是不支持这些的，于是CommonJS和AMD应运而生，我们可以使用requireJS库模块化前端代码。通过webpack打包代码，将所有代码打包成一个文件。这样减少了HTTP的请求以及解决了文件依赖的问题。

针对CSS，我们使用预编译语言less或者sass实现模块化，通过@import语句可以引入其他模块。针对ES6,ES7,我们可以使用babel将其编译为ES5。这些方法主要是为了开发更加便捷，开发人员可以更加高效的开发代码。


而这些工作，我们需要一个打包工具通过构建流程管理来帮我们完成这些任务。webpack作为一个打包工具，我们可以通过相关的loader和plugin来构建流程。

因此，下一篇详细学习webpack。


