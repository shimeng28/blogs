---
title: 计算机基础-进制计算学习
date: 2019-03-17 22:17:17
tags: 计算机基础
---
### 基础内容

#### 进制的概述

计算机使用二进制是因为其简单，只有两种状态，0和1，相当于开关的开和关，电平的高电平和低电平。但是由于在使用的过程中，二进制表示的数值太长，所以衍生出了八进制，16进制，因为其都是2的幂次方。

```
1024 === 0b10000000000
1024 === 0O2000
1024 === ox400
```

#### 整数二进制转换十进制 按权展开法
```
N = (1100101) = 1 * 2^6 + 1 * 2^5 + 1 * 2^2 + 1 = 101
```

#### 整数十进制转成二进制 辗转相除法

|除2|得商|取余|
|---|---|---|
|108 / 2|54|0|
|54 / 2|27|0|
|27 / 2|13|1|
|13 / 2|6|1|
|6 / 2|3|0|
|3 / 2|1|1|
|1 / 2|0|1|

所以结果为 1101100

#### 小数二进制转换十进制 按权展开法
```
N = (0.11001) = 1 * 2^(-1) + 1 * 2^(-2) + 1 * 2^(-5) = 32 / 25
```

#### 小数十进制转成二进制 重复相乘法
|乘2|得积|取1|
|---|---|---|
|25/32 * 2|9/16|1|
|9/16 * 2|1/8|1|
|1/8|1/4|0|
|1/4|1/2|0|
|1/2|0|1|

所以结果为0.11001

正数和负数
最前面一位 使用0表示正数，使用1表示负数

108 = 01101100

-108 = 11101100


### 二进制的表示方法

#### 原码表示法
符号位为第一位，0表示正数，1表示负数

缺点

1. 0有两种表示方法 00、10
2. 原码进行运算的时候非常复杂，特别是两个符号位不同的时候

   - 先判断两个操作数绝对值大小
   - 使用绝对值大的数减去绝对值小的数
   - 对于符号值，以绝对值大的为准
   
因此

1. 需要找到不同符号操作数更加简单的运算方法
2. 找到使用正数代替负数的方法
3. 使用加法操作代替减法操作，从而消除减法

#### 补码表示法
```
       x    x >= 0
x = 
       2^(n + 1) + x     x < 0  n为其位数
```

举例：位数n=4

如13， 其原码为0,1101  补码为1101

-13, 其原码为1,1101 补码为100000 - 1101 =  10011

0， 其原码为0,0000  补码为0,0000

通过以上可以看出在原码中会有第一位为符号位，所以会有正0和负0，但是在补码中其实并不算是有符号位，只能说是恰好首位为1的表示为负数，因此这也是为什么已经有了原码后还会出来补码的原因，第一使用正数代替负数，第二，所有的不同符号位都可以通过相加来计算。

但是它仍然没有消除减法，为什么呢？因为我们通过上面的例子也能看出，当我们求得一个数的补码的时候是通过减法计算获得的。

#### 反码表示法
```
       x    x >= 0
x = 
       2^(n + 1) - 1 + x     x < 0  n为其位数
```
举例：位数n=4

如13， 其原码为0,1101  反码为1101
 
-13，其原码为1,1101 反码为 100000 - 1- 1101 = 011111 - 1101 = 10010

我们知道使用反码的作用其实就是将求补码过程中的减法操作使用加法操作所替代，那么如何来替代呢？先讲三种表示方法放到一块看下

|数值|原码|反码|补码|
|---|---|---|---|
|0|0000|0000|0000|
|13|1101|1101|1101|
|-13|1,1101|10010|10011|
|-7|1,0111|11000|11001|

虽然说反码和补码的最高位并不能说是符号位，因为我们引入反码和补码的原因就是使用正数表示负数，可以认为所有的反码和补码都是正数。但是当一个数值为负数的时候呢，反码和补码的最高位正好为1，因此我们也可以认为其为符号位。当抛开最高位的时候能够发现，对于正数来说，原码、反码、补码的值是一样的，但是对于负数来说，反码为原码取反，补码是反码+1，因此补码就是原码先取反再+1。这样的话，如果我们将所有的数值都以补码来表示的话，那么在整个数值计算过程中就没有了减法，因为所有的数值都可以用正数来表示，不同符号位的数值也能直接通过相加来操作，减法可以当作加法来计算。

对于小数来说，也可以通过上面总结的来计算其补码

```
       x   1 > x >= 0
x = 
       2 + x   0 > x >= -1  
```


例如 9/16
其原码为 0,0.1001 反码为0,0.1001 补码为：0,0.1001

-9/16
其原码为 1,0.1001 反码为1,1.0110 补码为：1,1.0111



#### 定点数

将小数点固定在某个位置，如将小数点放到符号位和数值位之间，或者将小数点放到数值位之后

```
纯小数表示： 符号位【小数点】数值位
纯整数表示： 符号位 数值位 【小数点】
非纯整数和纯小数：使用两个定点数，一部分表示小数，一部分表示阶码
```

如
```
-0.1001 符号位为1  数值位为：1001 小数点在符号位和数值位中间
-1101   符号位为1  数值位为  1101  小数点在数值位最后
-1.0011 可以表示为 -0.10011 * 2^1 这个时候可以使用两个定点数表示
   纯小数：符号位为1  数值位为10011
   纯整数：符号为为0  数值位为00001
```

#### 定点数加减法运算

整数加法：A[补] + A[补] = [A+B][补](mod2^(n+1))
小数加法：A[补] + A[补] = [A+B][补](mod2)

数值位和符号位一同运算，将符号位产生的进位丢掉

```
A = -10010000, B = -11010000

A[补] = 1,01110000
B[补] = 1,00110000

A[补] + A[补] = 0,10100000 = 160 发生溢出
```

#### 双符号位判断溢出
```
A = -10010000, B = -11010000

A[补] = 11,01110000
B[补] = 11,00110000

A[补] + A[补] = 10,10100000 双符号位不同发生溢出
```


#### 浮点数

定点树主要表示纯小数和纯整数，但是并不是所有的数值都是纯整数和纯小数，而如果这个时候还用定点数的话就需要使用两个定点树才能表示一个数，因此自然引申出来浮点数

```
N = S * r ^ j  S为尾数  r为基数 j为阶码 S必须为纯小数
```
浮点数的表示方法为：

|阶码符号位|阶数值位|尾数符号位|尾数数值位|
|---|---|---|---|
|sign|j|sign|S|


例如：

```
11.0101 = 0.110101 * 2 ^(10)
```
|阶码符号位|阶数值位|尾数符号位|尾数数值位|
|---|---|---|---|
|0|10|0|110101|

浮点数的表示范围：

假设阶码的数值位为m位，尾数数值取n位
|


阶码表示的最大值为1....1 m个1 则值为2^m - 1。 因此考虑符号位之后 表示的区间范围为：[-(2^m - 1), 2^m - 1]

尾数表示的最大值为0.1...1 n个1 则值为1 - 2^(-n) 

尾数表示的最小小值为0.0...01  最后一位为1，n-1个0 则值为2^(-n)

考虑符号位之后表示的区间位[-(1 - 2^(-n)), -2^(-n)] [2^(-n), 1 - 2^(-n)]

因此 浮点数所表示的数值范围

```
_____________________________________________________________________________________________________________________
-(1 - 2^(-n))*2^(2^m - 1)       -2^(-n)*2^(-(2^m - 1))      2^(-n)*2^(-(2^m - 1))                  (1 - 2^(-n))*2^(2^m - 1) 
```

所以表示的范围为[  -(1 - 2^(-n))\*2^(2^m - 1), -2^(-n)\*2^(-(2^m - 1)) ] 和 [ 2^(-n)\*2^(-(2^m - 1)) , (1 - 2^(-n))\*2^(2^m - 1)]

因此有单精度浮点数32位(float)和双精度浮点数64位(double)


我们知道在JavaScript中是根据IEEE 754标准使用double双精度的数值来表示Number

例如：0.1101 表示为 1.101* 2^(-1)

0.01101 表示为 1.101 * 2^(-10)

|尾数符号位|阶码|尾数数值位|
|---|---|---|
|1|11|52|

尾数规范化时需要加1，因此可以表示的区间范围为[1, 2), 52位的尾数绝对值最大表示为 2 - 2^-52, 绝对值最小值为 1

阶码并不是通过补码来表示的，而是通过一个无符号的正整数表示的，因此将阶码分成两半是[-1023, 1024], 全0和全1作为边界条件，因此阶码的表示范围就是[-1022, 1023]

因此IEE 754 double类型可以表示的范围为

```
绝对值最大： (2 - 2^-52) * 2 ^ 1023 = 2^971 * (2^53 - 1) = 1.7976931348623157e+308
绝对值最小： 1 * 2^-1022 = 2.2250738585072014e-308
```

这是我们按照上面的规范说明的最大最小值，但是实际上我们抛弃了阶码中全为0和全为1的情况。

1. 阶码全为1, 尾数全为0 表示无穷大 ∞
2. 阶码全为1，尾部不全为0 表示NaN
3. 阶码全为0，尾数全为0  表示0
3. 阶码全为0，尾数不全为0 表示为一群非常接近0的数，这种情况下尾数不再加一，最小值为2^-52，因此绝对值最小的其实为2^-52 * 2^-1022 = 2^-1074 = 5e-324

由这些可知，在JavaScript中，包括所有使用IEEE 754标准的double双精度浮点数的表示区间范围为

[-1.7976931348623157e+308, -5e-324] 和 [5e-324, 1.7976931348623157e+308]  其中绝对值超过1.7976931348623157e+308的值则发生上溢，绝对值小于5e-324则发生下溢

并且通过这些也能看出来，针对小数部分，所有其分母不是2的倍数的值计算机并不能非常准确的表示，这也是为什么0.1 + 0.2 != 0.3了